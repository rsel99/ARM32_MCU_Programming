.cpu cortex-m0
.thumb
.syntax unified
.fpu softvfp

.global sq
sq:
    push {lr}
    movs r1, r0
    muls r0, r1
    pop {pc}

.global sumsq
sumsq:
    push {r4-r7, lr}
    movs r4, r0
    movs r5, r1
    
    movs r6, #0		// sum
    for1:
        movs r7, r4     // n
    check1:
        cmp r7, r5
        bgt endfor1
    body1:
        movs r0, r7
        bl sq
        adds r6, r0
    next1:
        adds r7, #1
        b check1
    endfor1:    
    movs r0, r6
    pop {r4-r7, pc}

.global log2
log2:
    push {lr}
    ldr r1, =0xffffffff
    while1:
        cmp r0, #0
        bls endwhile1
    do1:
        lsrs r0, r0, #1
        adds r1, #1
        b while1
    endwhile1:
        movs r0, r1
    pop {pc}

.global divide
divide:
    push {r4-r7, lr}
    cmp r1, #0
    beq divzero
    
    cmp r1, r0
    bhi retzero
    
    movs r4, r0             // n
    movs r5, r1             // d
    bl log2
    movs r6, r0             // nbits
    movs r0, r5
    bl log2
    movs r7, r0             // dbits
    
    movs r0, r6
    subs r0, r7             // shift
    
    lsls r5, r5, r0
    movs r1, #0             // q
    
    for2:
    check2:
        cmp r0, #0
        blt endfor2
    body2:
        lsls r1, r1, #1
        if1:
            cmp r5, r4
            bgt endif1
        then1:
            subs r4, r4, r5
            movs r2, #1
            orrs r1, r2
        endif1:
        lsrs r5, r5, #1
    next2:
        subs r0, #1
        b check2
    endfor2:
        movs r0, r1
        b returndiv

    divzero:
        ldr r0, =0xffffffff
	    b returndiv
    retzero:
        movs r0, #0
        b returndiv
    returndiv:
        pop {r4-r7, pc}

.global itersqrt
itersqrt:
    push {r4, lr}
    
    cmp r0, #1
    bls retitsq
    
    movs r4, r0
    bl log2
    adds r0, #1
    
    movs r2, #1
    movs r1, r0
    ands r1, r2
    adds r0, r1                 // shift
    
    movs r1, #0                 // result
    do2:
        movs r2, #1
        subs r0, #2
        lsls r1, r1, #1
        orrs r1, r2
        if2:
            movs r3, r1
            muls r3, r1
            movs r2, r4
            lsrs r2, r0
            cmp r3, r2
            bls endif2
        then2:
            movs r2, #1
            eors r1, r2
        endif2:
    while2:
        cmp r0, #0
        bls endwhile2
        b do2
    endwhile2:
        movs r0, r1
    
    retitsq:
        pop {r4, pc}

.global recsqrt
recsqrt:
    push {r4, lr}
    
    cmp r0, #1
    bls retrecsq
    
    movs r4, r0
    lsrs r0, r0, #2
    bl recsqrt
    lsls r0, r0, #1
    
    movs r1, r0
    adds r1, #1
    
    if3:
        movs r2, r1
        muls r2, r1
        cmp r2, r4
        bls else3
    then3:
        b retrecsq
    else3:
        movs r0, r1
        b retrecsq
    endif3:
    
    retrecsq:
        pop {r4, pc}

.global fun16
fun16:
    push {r4, lr}
    if4:
    	cmp r0, #3
    	bhi endif4
    then4:
        subs r0, #1
	b retfun16
    endif4:
        movs r4, r0
        subs r0, #1
	bl fun16
        muls r0, r4
	subs r0, #1
    retfun16:
	pop {r4, pc}

.global doublerec
doublerec:
    push {r4, r5, lr}
    if5:
	cmp r0, #3
	bhi endif5
    then5:
	b retdorec
    endif5:
	movs r4, r0
	lsrs r0, r0, #1
	bl doublerec
	movs r5, r0
	movs r0, r4
	lsrs r0, r0, #2
	bl doublerec
	adds r0, r5
    retdorec:
        pop {r4, r5, pc}

.global vectoradd
vectoradd:
    push {r4-r7, lr}
    for3:
	movs r4, #0			// n
    check3:
	cmp r4, r0
	bge endfor3
    body3:
	movs r7, r4
	lsls r7, r7, #2
	ldr r5, [r2, r7]
	ldr r6, [r3, r7]
	adds r5, r6
	str r5, [r1, r7]
    next3:
	adds r4, #1
	b check3
    endfor3:
    pop {r4-r7, pc}

.global updatesum
updatesum:
    push {r4, r5, lr}
    movs r2, #0
    for4:
	movs r3, #0
    check4:
	cmp r3, r1
	bge endfor4
    body4:
	movs r5, r3
	lsls r5, r5, #2
	ldr r4, [r0, r5]
	adds r2, r4
	adds r4, #1
	str r4, [r0, r5]
    next4:
	adds r3, #1
	b check4
    endfor4:
	movs r0, r2
    pop {r4, r5, pc}

.global globalsum
globalsum:
    push {r4, r5, lr}
    movs r1, #0
    for5:
	movs r2, #0
    check5:
	cmp r2, r0
	bge endfor5
    body5:
	movs r4, r2
	lsls r4, r4, #2
	ldr r3, =global_array
	ldr r5, [r3, r4]
	adds r1, r5
    next5:
	adds r2, #1
	b check5
    endfor5:
	movs r0, r1
    pop {r4, r5, pc}

// Leave this down here just in case
// you forget to return from a subroutine.
bkpt

// Because this array is "const", we can
// put it in the text segment (which is
// in the Flash ROM.  It cannot be modified.
bx lr // put a return here just in case you missed one above.
.global global_array
.align 4
global_array:
.word 2, 3, 5, 7, 11, 13, 17, 19, 23, 29